"""
3D Landmarks Visualizer

This module provides functionality to visualize sign language landmarks in 3D space
from video_landmarks.json files generated by the processing pipeline.

Usage:
    from visualizer_3d import visualize_landmarks_3d
    visualize_landmarks_3d("path/to/video_landmarks.json")
"""

import json
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.animation import FuncAnimation
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import argparse


class LandmarksVisualizer3D:
    """3D visualizer for sign language landmarks"""

    def __init__(self, json_path: str, frame_rate: float = 10.0):
        """
        Initialize the 3D visualizer

        Args:
            json_path: Path to video_landmarks.json file
            frame_rate: Animation frame rate (frames per second)
        """
        self.json_path = Path(json_path)
        self.frame_rate = frame_rate
        self.data = None
        self.frames_data = None
        self.metadata = None
        self.current_frame = 0

        # Color scheme for different landmark types
        self.colors = {
            'hands': {'left_hand': 'red', 'right_hand': 'blue'},
            'face': 'yellow',
            'pose': 'green'
        }

        # Load data
        self._load_data()

    def _load_data(self):
        """Load landmarks data from JSON file"""
        if not self.json_path.exists():
            raise FileNotFoundError(f"JSON file not found: {self.json_path}")

        try:
            with open(self.json_path, 'r') as f:
                self.data = json.load(f)

            self.metadata = self.data.get('metadata', {})
            self.frames_data = self.data.get('frames', {})

            if not self.frames_data:
                raise ValueError("No frames data found in JSON file")

            print(f"Loaded data for {len(self.frames_data)} frames")
            print(f"Source: {self.metadata.get('input_source', 'Unknown')}")
            print(f"FPS: {self.metadata.get('fps', 'Unknown')}")

        except Exception as e:
            raise Exception(f"Error loading JSON file: {e}")

    def _extract_landmarks_for_frame(self, frame_key: str) -> Dict:
        """Extract 3D coordinates for a specific frame"""
        frame_data = self.frames_data.get(frame_key, {})
        landmarks_3d = {
            'hands': {'left_hand': [], 'right_hand': []},
            'face': [],
            'pose': []
        }

        # Extract hand landmarks
        hands_data = frame_data.get('hands', {})
        for hand_type in ['left_hand', 'right_hand']:
            hand_info = hands_data.get(hand_type, {})
            if isinstance(hand_info, dict) and 'landmarks' in hand_info:
                # New format with confidence
                hand_landmarks = hand_info['landmarks']
            elif isinstance(hand_info, list):
                # Old format - direct list
                hand_landmarks = hand_info
            else:
                hand_landmarks = []

            if hand_landmarks:
                points = np.array([[lm['x'], lm['y'], lm['z']] for lm in hand_landmarks])
                landmarks_3d['hands'][hand_type] = points

        # Extract face landmarks (using all landmarks)
        face_data = frame_data.get('face', {})
        if 'all_landmarks' in face_data and face_data['all_landmarks']:
            # Use a subset of face landmarks for better visualization
            face_landmarks = face_data['all_landmarks']
            # Take every 10th landmark to reduce clutter
            sampled_landmarks = face_landmarks[::10]
            points = np.array([[lm['x'], lm['y'], lm['z']] for lm in sampled_landmarks])
            landmarks_3d['face'] = points

        # Extract pose landmarks
        pose_data = frame_data.get('pose', {})
        if pose_data:
            # Extract key pose landmarks
            key_pose_points = [
                'NOSE', 'LEFT_EYE', 'RIGHT_EYE', 'LEFT_EAR', 'RIGHT_EAR',
                'LEFT_SHOULDER', 'RIGHT_SHOULDER', 'LEFT_ELBOW', 'RIGHT_ELBOW',
                'LEFT_WRIST', 'RIGHT_WRIST', 'LEFT_HIP', 'RIGHT_HIP',
                'LEFT_KNEE', 'RIGHT_KNEE', 'LEFT_ANKLE', 'RIGHT_ANKLE'
            ]

            pose_points = []
            for landmark_name in key_pose_points:
                if landmark_name in pose_data:
                    lm = pose_data[landmark_name]
                    # Check visibility if available
                    visibility = lm.get('visibility', 1.0)
                    if visibility > 0.5:  # Only include visible landmarks
                        pose_points.append([lm['x'], lm['y'], lm['z']])

            if pose_points:
                landmarks_3d['pose'] = np.array(pose_points)

        return landmarks_3d

    def _setup_3d_plot(self):
        """Set up the 3D matplotlib plot"""
        self.fig = plt.figure(figsize=(12, 9))
        self.ax = self.fig.add_subplot(111, projection='3d')

        # Set labels and title
        self.ax.set_xlabel('X')
        self.ax.set_ylabel('Y')
        self.ax.set_zlabel('Z')
        self.ax.set_title(f'3D Landmarks Visualization\nSource: {self.metadata.get("input_source", "Unknown")}')

        # Set axis limits (normalized coordinates are 0-1)
        self.ax.set_xlim(0, 1)
        self.ax.set_ylim(0, 1)
        self.ax.set_zlim(-0.5, 0.5)  # Z coordinates are typically smaller

        # Invert Y axis to match image coordinates
        self.ax.invert_yaxis()

        return self.ax

    def _draw_frame(self, frame_num: int):
        """Draw landmarks for a specific frame"""
        self.ax.clear()

        # Set up plot again
        self.ax.set_xlabel('X')
        self.ax.set_ylabel('Y')
        self.ax.set_zlabel('Z')
        self.ax.set_xlim(0, 1)
        self.ax.set_ylim(0, 1)
        self.ax.set_zlim(-0.5, 0.5)
        self.ax.invert_yaxis()

        # Get frame key
        frame_keys = sorted(self.frames_data.keys(), key=int)
        if frame_num >= len(frame_keys):
            frame_num = len(frame_keys) - 1

        frame_key = frame_keys[frame_num]
        landmarks = self._extract_landmarks_for_frame(frame_key)

        # Draw hand landmarks
        for hand_type, points in landmarks['hands'].items():
            if len(points) > 0:
                color = self.colors['hands'][hand_type]
                self.ax.scatter(points[:, 0], points[:, 1], points[:, 2],
                                c=color, s=30, alpha=0.8, label=f'{hand_type.replace("_", " ").title()}')

                # Draw hand connections (simplified)
                self._draw_hand_connections(points, color)

        # Draw face landmarks
        if len(landmarks['face']) > 0:
            self.ax.scatter(landmarks['face'][:, 0], landmarks['face'][:, 1], landmarks['face'][:, 2],
                            c=self.colors['face'], s=10, alpha=0.6, label='Face')

        # Draw pose landmarks
        if len(landmarks['pose']) > 0:
            self.ax.scatter(landmarks['pose'][:, 0], landmarks['pose'][:, 1], landmarks['pose'][:, 2],
                            c=self.colors['pose'], s=50, alpha=0.8, label='Pose')

            # Draw pose connections
            self._draw_pose_connections(landmarks['pose'])

        # Update title with frame info
        frame_timestamp = float(frame_key) / self.metadata.get('fps', 30)
        self.ax.set_title(f'Frame {frame_key} (t={frame_timestamp:.2f}s)\n'
                          f'Source: {self.metadata.get("input_source", "Unknown")}')

        # Add legend
        self.ax.legend(loc='upper left', bbox_to_anchor=(0, 1))

        return self.ax

    def _draw_hand_connections(self, points: np.ndarray, color: str):
        """Draw connections between hand landmarks"""
        if len(points) != 21:  # MediaPipe hand has 21 landmarks
            return

        # Define hand connections (simplified version)
        connections = [
            # Thumb
            (0, 1), (1, 2), (2, 3), (3, 4),
            # Index finger
            (0, 5), (5, 6), (6, 7), (7, 8),
            # Middle finger
            (0, 9), (9, 10), (10, 11), (11, 12),
            # Ring finger
            (0, 13), (13, 14), (14, 15), (15, 16),
            # Pinky
            (0, 17), (17, 18), (18, 19), (19, 20),
            # Palm connections
            (5, 9), (9, 13), (13, 17)
        ]

        for start_idx, end_idx in connections:
            start_point = points[start_idx]
            end_point = points[end_idx]
            self.ax.plot([start_point[0], end_point[0]],
                         [start_point[1], end_point[1]],
                         [start_point[2], end_point[2]],
                         color=color, alpha=0.5, linewidth=1)

    def _draw_pose_connections(self, points: np.ndarray):
        """Draw connections between pose landmarks"""
        # This is simplified - would need to map the actual pose landmark indices
        # For now, just connect some basic points
        if len(points) >= 4:
            # Connect shoulders to create basic pose structure
            color = self.colors['pose']
            for i in range(len(points) - 1):
                if i % 2 == 0 and i + 1 < len(points):  # Connect pairs
                    self.ax.plot([points[i][0], points[i + 1][0]],
                                 [points[i][1], points[i + 1][1]],
                                 [points[i][2], points[i + 1][2]],
                                 color=color, alpha=0.3, linewidth=1)

    def visualize_static(self, frame_number: Optional[int] = None):
        """Display a static 3D visualization of landmarks for a specific frame"""
        self._setup_3d_plot()

        if frame_number is None:
            frame_number = 0

        self._draw_frame(frame_number)

        # Add instructions
        plt.figtext(0.02, 0.02, 'Use mouse to rotate view. Close window to exit.',
                    fontsize=10, style='italic')

        plt.tight_layout()
        plt.show()

    def visualize_animated(self, interval: float = 100):
        """Display an animated 3D visualization of landmarks across all frames"""
        self._setup_3d_plot()

        frame_keys = sorted(self.frames_data.keys(), key=int)
        total_frames = len(frame_keys)

        def animate(frame):
            return self._draw_frame(frame)

        # Create animation
        self.anim = FuncAnimation(self.fig, animate, frames=total_frames,
                                  interval=interval, blit=False, repeat=True)

        # Add instructions
        plt.figtext(0.02, 0.02, 'Animation playing. Use mouse to rotate view. Close window to exit.',
                    fontsize=10, style='italic')

        plt.tight_layout()
        plt.show()

        return self.anim

    def save_animation(self, output_path: str, fps: float = 10):
        """Save the 3D animation as a video file"""
        self._setup_3d_plot()

        frame_keys = sorted(self.frames_data.keys(), key=int)
        total_frames = len(frame_keys)

        def animate(frame):
            return self._draw_frame(frame)

        # Create animation
        anim = FuncAnimation(self.fig, animate, frames=total_frames,
                             interval=1000 / fps, blit=False, repeat=False)

        # Save animation
        print(f"Saving 3D animation to {output_path}...")
        anim.save(output_path, writer='pillow', fps=fps)
        print(f"Animation saved successfully!")

        plt.close()


def visualize_landmarks_3d(json_path: str, mode: str = 'static', frame_number: Optional[int] = None,
                           save_path: Optional[str] = None):
    """
    Visualize landmarks from video_landmarks.json in 3D space

    Args:
        json_path: Path to the video_landmarks.json file
        mode: 'static' for single frame, 'animated' for animation
        frame_number: Specific frame to show (for static mode), None for first frame
        save_path: Path to save animation (optional, for animated mode)
    """
    try:
        visualizer = LandmarksVisualizer3D(json_path)

        if mode == 'static':
            visualizer.visualize_static(frame_number)
        elif mode == 'animated':
            if save_path:
                visualizer.save_animation(save_path)
            else:
                visualizer.visualize_animated()
        else:
            raise ValueError("Mode must be 'static' or 'animated'")

    except Exception as e:
        print(f"Error in visualization: {e}")
        raise


def main():
    """Command line interface for 3D visualization"""
    parser = argparse.ArgumentParser(description='Visualize sign language landmarks in 3D')
    parser.add_argument('json_path', help='Path to video_landmarks.json file')
    parser.add_argument('--mode', choices=['static', 'animated'], default='static',
                        help='Visualization mode (default: static)')
    parser.add_argument('--frame', type=int, default=0,
                        help='Frame number to display (for static mode, default: 0)')
    parser.add_argument('--save', type=str,
                        help='Save animation to file (for animated mode)')

    args = parser.parse_args()

    print(f"Loading landmarks from: {args.json_path}")
    print(f"Mode: {args.mode}")

    if args.mode == 'static':
        print(f"Displaying frame: {args.frame}")

    visualize_landmarks_3d(args.json_path, args.mode, args.frame, args.save)


if __name__ == "__main__":
    main()